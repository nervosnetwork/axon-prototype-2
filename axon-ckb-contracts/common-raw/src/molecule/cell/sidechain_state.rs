// Generated by Molecule 0.7.0

use super::super::common::*;
use molecule::prelude::*;
#[derive(Clone)]
pub struct Jobs(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Jobs {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Jobs {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Jobs {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl ::core::default::Default for Jobs {
    fn default() -> Self {
        let v: Vec<u8> = vec![0, 0, 0, 0];
        Jobs::new_unchecked(v.into())
    }
}
impl Jobs {
    pub const ITEM_SIZE: usize = 32;

    pub fn total_size(&self) -> usize {
        molecule::NUMBER_SIZE * (self.item_count() + 1)
    }

    pub fn item_count(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }

    pub fn len(&self) -> usize {
        self.item_count()
    }

    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }

    pub fn get(&self, idx: usize) -> Option<BlockSlice> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }

    pub fn get_unchecked(&self, idx: usize) -> BlockSlice {
        let start = molecule::NUMBER_SIZE + Self::ITEM_SIZE * idx;
        let end = start + Self::ITEM_SIZE;
        BlockSlice::new_unchecked(self.0.slice(start..end))
    }

    pub fn as_reader<'r>(&'r self) -> JobsReader<'r> {
        JobsReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Jobs {
    type Builder = JobsBuilder;

    const NAME: &'static str = "Jobs";

    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Jobs(data)
    }

    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }

    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }

    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        JobsReader::from_slice(slice).map(|reader| reader.to_entity())
    }

    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        JobsReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }

    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }

    fn as_builder(self) -> Self::Builder {
        Self::new_builder().extend(self.into_iter())
    }
}
#[derive(Clone, Copy)]
pub struct JobsReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for JobsReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for JobsReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for JobsReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl<'r> JobsReader<'r> {
    pub const ITEM_SIZE: usize = 32;

    pub fn total_size(&self) -> usize {
        molecule::NUMBER_SIZE * (self.item_count() + 1)
    }

    pub fn item_count(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }

    pub fn len(&self) -> usize {
        self.item_count()
    }

    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }

    pub fn get(&self, idx: usize) -> Option<BlockSliceReader<'r>> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }

    pub fn get_unchecked(&self, idx: usize) -> BlockSliceReader<'r> {
        let start = molecule::NUMBER_SIZE + Self::ITEM_SIZE * idx;
        let end = start + Self::ITEM_SIZE;
        BlockSliceReader::new_unchecked(&self.as_slice()[start..end])
    }
}
impl<'r> molecule::prelude::Reader<'r> for JobsReader<'r> {
    type Entity = Jobs;

    const NAME: &'static str = "JobsReader";

    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }

    fn new_unchecked(slice: &'r [u8]) -> Self {
        JobsReader(slice)
    }

    fn as_slice(&self) -> &'r [u8] {
        self.0
    }

    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let item_count = molecule::unpack_number(slice) as usize;
        if item_count == 0 {
            if slice_len != molecule::NUMBER_SIZE {
                return ve!(Self, TotalSizeNotMatch, molecule::NUMBER_SIZE, slice_len);
            }
            return Ok(());
        }
        let total_size = molecule::NUMBER_SIZE + Self::ITEM_SIZE * item_count;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct JobsBuilder(pub(crate) Vec<BlockSlice>);
impl JobsBuilder {
    pub const ITEM_SIZE: usize = 32;

    pub fn set(mut self, v: Vec<BlockSlice>) -> Self {
        self.0 = v;
        self
    }

    pub fn push(mut self, v: BlockSlice) -> Self {
        self.0.push(v);
        self
    }

    pub fn extend<T: ::core::iter::IntoIterator<Item = BlockSlice>>(mut self, iter: T) -> Self {
        for elem in iter {
            self.0.push(elem);
        }
        self
    }
}
impl molecule::prelude::Builder for JobsBuilder {
    type Entity = Jobs;

    const NAME: &'static str = "JobsBuilder";

    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.0.len()
    }

    fn write<W: ::molecule::io::Write>(&self, writer: &mut W) -> ::molecule::io::Result<()> {
        writer.write_all(&molecule::pack_number(self.0.len() as molecule::Number))?;
        for inner in &self.0[..] {
            writer.write_all(inner.as_slice())?;
        }
        Ok(())
    }

    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Jobs::new_unchecked(inner.into())
    }
}
pub struct JobsIterator(Jobs, usize, usize);
impl ::core::iter::Iterator for JobsIterator {
    type Item = BlockSlice;

    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl ::core::iter::ExactSizeIterator for JobsIterator {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::core::iter::IntoIterator for Jobs {
    type IntoIter = JobsIterator;
    type Item = BlockSlice;

    fn into_iter(self) -> Self::IntoIter {
        let len = self.len();
        JobsIterator(self, 0, len)
    }
}
impl<'r> JobsReader<'r> {
    pub fn iter<'t>(&'t self) -> JobsReaderIterator<'t, 'r> {
        JobsReaderIterator(&self, 0, self.len())
    }
}
pub struct JobsReaderIterator<'t, 'r>(&'t JobsReader<'r>, usize, usize);
impl<'t: 'r, 'r> ::core::iter::Iterator for JobsReaderIterator<'t, 'r> {
    type Item = BlockSliceReader<'t>;

    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl<'t: 'r, 'r> ::core::iter::ExactSizeIterator for JobsReaderIterator<'t, 'r> {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
#[derive(Clone)]
pub struct CommittedCheckerInfo(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for CommittedCheckerInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for CommittedCheckerInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for CommittedCheckerInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "checker_lock_arg", self.checker_lock_arg())?;
        write!(f, ", {}: {}", "committed_hash", self.committed_hash())?;
        write!(f, " }}")
    }
}
impl ::core::default::Default for CommittedCheckerInfo {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        ];
        CommittedCheckerInfo::new_unchecked(v.into())
    }
}
impl CommittedCheckerInfo {
    pub const FIELD_COUNT: usize = 2;
    pub const FIELD_SIZES: [usize; 2] = [20, 32];
    pub const TOTAL_SIZE: usize = 52;

    pub fn checker_lock_arg(&self) -> PubKeyHash {
        PubKeyHash::new_unchecked(self.0.slice(0..20))
    }

    pub fn committed_hash(&self) -> CommittedHash {
        CommittedHash::new_unchecked(self.0.slice(20..52))
    }

    pub fn as_reader<'r>(&'r self) -> CommittedCheckerInfoReader<'r> {
        CommittedCheckerInfoReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for CommittedCheckerInfo {
    type Builder = CommittedCheckerInfoBuilder;

    const NAME: &'static str = "CommittedCheckerInfo";

    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        CommittedCheckerInfo(data)
    }

    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }

    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }

    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        CommittedCheckerInfoReader::from_slice(slice).map(|reader| reader.to_entity())
    }

    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        CommittedCheckerInfoReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }

    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }

    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .checker_lock_arg(self.checker_lock_arg())
            .committed_hash(self.committed_hash())
    }
}
#[derive(Clone, Copy)]
pub struct CommittedCheckerInfoReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for CommittedCheckerInfoReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for CommittedCheckerInfoReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for CommittedCheckerInfoReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "checker_lock_arg", self.checker_lock_arg())?;
        write!(f, ", {}: {}", "committed_hash", self.committed_hash())?;
        write!(f, " }}")
    }
}
impl<'r> CommittedCheckerInfoReader<'r> {
    pub const FIELD_COUNT: usize = 2;
    pub const FIELD_SIZES: [usize; 2] = [20, 32];
    pub const TOTAL_SIZE: usize = 52;

    pub fn checker_lock_arg(&self) -> PubKeyHashReader<'r> {
        PubKeyHashReader::new_unchecked(&self.as_slice()[0..20])
    }

    pub fn committed_hash(&self) -> CommittedHashReader<'r> {
        CommittedHashReader::new_unchecked(&self.as_slice()[20..52])
    }
}
impl<'r> molecule::prelude::Reader<'r> for CommittedCheckerInfoReader<'r> {
    type Entity = CommittedCheckerInfo;

    const NAME: &'static str = "CommittedCheckerInfoReader";

    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }

    fn new_unchecked(slice: &'r [u8]) -> Self {
        CommittedCheckerInfoReader(slice)
    }

    fn as_slice(&self) -> &'r [u8] {
        self.0
    }

    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct CommittedCheckerInfoBuilder {
    pub(crate) checker_lock_arg: PubKeyHash,
    pub(crate) committed_hash:   CommittedHash,
}
impl CommittedCheckerInfoBuilder {
    pub const FIELD_COUNT: usize = 2;
    pub const FIELD_SIZES: [usize; 2] = [20, 32];
    pub const TOTAL_SIZE: usize = 52;

    pub fn checker_lock_arg(mut self, v: PubKeyHash) -> Self {
        self.checker_lock_arg = v;
        self
    }

    pub fn committed_hash(mut self, v: CommittedHash) -> Self {
        self.committed_hash = v;
        self
    }
}
impl molecule::prelude::Builder for CommittedCheckerInfoBuilder {
    type Entity = CommittedCheckerInfo;

    const NAME: &'static str = "CommittedCheckerInfoBuilder";

    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }

    fn write<W: ::molecule::io::Write>(&self, writer: &mut W) -> ::molecule::io::Result<()> {
        writer.write_all(self.checker_lock_arg.as_slice())?;
        writer.write_all(self.committed_hash.as_slice())?;
        Ok(())
    }

    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        CommittedCheckerInfo::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct CommittedCheckerInfos(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for CommittedCheckerInfos {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for CommittedCheckerInfos {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for CommittedCheckerInfos {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl ::core::default::Default for CommittedCheckerInfos {
    fn default() -> Self {
        let v: Vec<u8> = vec![0, 0, 0, 0];
        CommittedCheckerInfos::new_unchecked(v.into())
    }
}
impl CommittedCheckerInfos {
    pub const ITEM_SIZE: usize = 52;

    pub fn total_size(&self) -> usize {
        molecule::NUMBER_SIZE * (self.item_count() + 1)
    }

    pub fn item_count(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }

    pub fn len(&self) -> usize {
        self.item_count()
    }

    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }

    pub fn get(&self, idx: usize) -> Option<CommittedCheckerInfo> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }

    pub fn get_unchecked(&self, idx: usize) -> CommittedCheckerInfo {
        let start = molecule::NUMBER_SIZE + Self::ITEM_SIZE * idx;
        let end = start + Self::ITEM_SIZE;
        CommittedCheckerInfo::new_unchecked(self.0.slice(start..end))
    }

    pub fn as_reader<'r>(&'r self) -> CommittedCheckerInfosReader<'r> {
        CommittedCheckerInfosReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for CommittedCheckerInfos {
    type Builder = CommittedCheckerInfosBuilder;

    const NAME: &'static str = "CommittedCheckerInfos";

    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        CommittedCheckerInfos(data)
    }

    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }

    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }

    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        CommittedCheckerInfosReader::from_slice(slice).map(|reader| reader.to_entity())
    }

    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        CommittedCheckerInfosReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }

    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }

    fn as_builder(self) -> Self::Builder {
        Self::new_builder().extend(self.into_iter())
    }
}
#[derive(Clone, Copy)]
pub struct CommittedCheckerInfosReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for CommittedCheckerInfosReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for CommittedCheckerInfosReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for CommittedCheckerInfosReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl<'r> CommittedCheckerInfosReader<'r> {
    pub const ITEM_SIZE: usize = 52;

    pub fn total_size(&self) -> usize {
        molecule::NUMBER_SIZE * (self.item_count() + 1)
    }

    pub fn item_count(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }

    pub fn len(&self) -> usize {
        self.item_count()
    }

    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }

    pub fn get(&self, idx: usize) -> Option<CommittedCheckerInfoReader<'r>> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }

    pub fn get_unchecked(&self, idx: usize) -> CommittedCheckerInfoReader<'r> {
        let start = molecule::NUMBER_SIZE + Self::ITEM_SIZE * idx;
        let end = start + Self::ITEM_SIZE;
        CommittedCheckerInfoReader::new_unchecked(&self.as_slice()[start..end])
    }
}
impl<'r> molecule::prelude::Reader<'r> for CommittedCheckerInfosReader<'r> {
    type Entity = CommittedCheckerInfos;

    const NAME: &'static str = "CommittedCheckerInfosReader";

    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }

    fn new_unchecked(slice: &'r [u8]) -> Self {
        CommittedCheckerInfosReader(slice)
    }

    fn as_slice(&self) -> &'r [u8] {
        self.0
    }

    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let item_count = molecule::unpack_number(slice) as usize;
        if item_count == 0 {
            if slice_len != molecule::NUMBER_SIZE {
                return ve!(Self, TotalSizeNotMatch, molecule::NUMBER_SIZE, slice_len);
            }
            return Ok(());
        }
        let total_size = molecule::NUMBER_SIZE + Self::ITEM_SIZE * item_count;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct CommittedCheckerInfosBuilder(pub(crate) Vec<CommittedCheckerInfo>);
impl CommittedCheckerInfosBuilder {
    pub const ITEM_SIZE: usize = 52;

    pub fn set(mut self, v: Vec<CommittedCheckerInfo>) -> Self {
        self.0 = v;
        self
    }

    pub fn push(mut self, v: CommittedCheckerInfo) -> Self {
        self.0.push(v);
        self
    }

    pub fn extend<T: ::core::iter::IntoIterator<Item = CommittedCheckerInfo>>(mut self, iter: T) -> Self {
        for elem in iter {
            self.0.push(elem);
        }
        self
    }
}
impl molecule::prelude::Builder for CommittedCheckerInfosBuilder {
    type Entity = CommittedCheckerInfos;

    const NAME: &'static str = "CommittedCheckerInfosBuilder";

    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.0.len()
    }

    fn write<W: ::molecule::io::Write>(&self, writer: &mut W) -> ::molecule::io::Result<()> {
        writer.write_all(&molecule::pack_number(self.0.len() as molecule::Number))?;
        for inner in &self.0[..] {
            writer.write_all(inner.as_slice())?;
        }
        Ok(())
    }

    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        CommittedCheckerInfos::new_unchecked(inner.into())
    }
}
pub struct CommittedCheckerInfosIterator(CommittedCheckerInfos, usize, usize);
impl ::core::iter::Iterator for CommittedCheckerInfosIterator {
    type Item = CommittedCheckerInfo;

    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl ::core::iter::ExactSizeIterator for CommittedCheckerInfosIterator {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::core::iter::IntoIterator for CommittedCheckerInfos {
    type IntoIter = CommittedCheckerInfosIterator;
    type Item = CommittedCheckerInfo;

    fn into_iter(self) -> Self::IntoIter {
        let len = self.len();
        CommittedCheckerInfosIterator(self, 0, len)
    }
}
impl<'r> CommittedCheckerInfosReader<'r> {
    pub fn iter<'t>(&'t self) -> CommittedCheckerInfosReaderIterator<'t, 'r> {
        CommittedCheckerInfosReaderIterator(&self, 0, self.len())
    }
}
pub struct CommittedCheckerInfosReaderIterator<'t, 'r>(&'t CommittedCheckerInfosReader<'r>, usize, usize);
impl<'t: 'r, 'r> ::core::iter::Iterator for CommittedCheckerInfosReaderIterator<'t, 'r> {
    type Item = CommittedCheckerInfoReader<'t>;

    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl<'t: 'r, 'r> ::core::iter::ExactSizeIterator for CommittedCheckerInfosReaderIterator<'t, 'r> {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
#[derive(Clone)]
pub struct PunishedChecker(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for PunishedChecker {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for PunishedChecker {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for PunishedChecker {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "checker_lock_arg", self.checker_lock_arg())?;
        write!(f, ", {}: {}", "punish_points", self.punish_points())?;
        write!(f, " }}")
    }
}
impl ::core::default::Default for PunishedChecker {
    fn default() -> Self {
        let v: Vec<u8> = vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        PunishedChecker::new_unchecked(v.into())
    }
}
impl PunishedChecker {
    pub const FIELD_COUNT: usize = 2;
    pub const FIELD_SIZES: [usize; 2] = [20, 4];
    pub const TOTAL_SIZE: usize = 24;

    pub fn checker_lock_arg(&self) -> PubKeyHash {
        PubKeyHash::new_unchecked(self.0.slice(0..20))
    }

    pub fn punish_points(&self) -> Uint32 {
        Uint32::new_unchecked(self.0.slice(20..24))
    }

    pub fn as_reader<'r>(&'r self) -> PunishedCheckerReader<'r> {
        PunishedCheckerReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for PunishedChecker {
    type Builder = PunishedCheckerBuilder;

    const NAME: &'static str = "PunishedChecker";

    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        PunishedChecker(data)
    }

    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }

    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }

    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        PunishedCheckerReader::from_slice(slice).map(|reader| reader.to_entity())
    }

    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        PunishedCheckerReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }

    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }

    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .checker_lock_arg(self.checker_lock_arg())
            .punish_points(self.punish_points())
    }
}
#[derive(Clone, Copy)]
pub struct PunishedCheckerReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for PunishedCheckerReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for PunishedCheckerReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for PunishedCheckerReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "checker_lock_arg", self.checker_lock_arg())?;
        write!(f, ", {}: {}", "punish_points", self.punish_points())?;
        write!(f, " }}")
    }
}
impl<'r> PunishedCheckerReader<'r> {
    pub const FIELD_COUNT: usize = 2;
    pub const FIELD_SIZES: [usize; 2] = [20, 4];
    pub const TOTAL_SIZE: usize = 24;

    pub fn checker_lock_arg(&self) -> PubKeyHashReader<'r> {
        PubKeyHashReader::new_unchecked(&self.as_slice()[0..20])
    }

    pub fn punish_points(&self) -> Uint32Reader<'r> {
        Uint32Reader::new_unchecked(&self.as_slice()[20..24])
    }
}
impl<'r> molecule::prelude::Reader<'r> for PunishedCheckerReader<'r> {
    type Entity = PunishedChecker;

    const NAME: &'static str = "PunishedCheckerReader";

    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }

    fn new_unchecked(slice: &'r [u8]) -> Self {
        PunishedCheckerReader(slice)
    }

    fn as_slice(&self) -> &'r [u8] {
        self.0
    }

    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct PunishedCheckerBuilder {
    pub(crate) checker_lock_arg: PubKeyHash,
    pub(crate) punish_points:    Uint32,
}
impl PunishedCheckerBuilder {
    pub const FIELD_COUNT: usize = 2;
    pub const FIELD_SIZES: [usize; 2] = [20, 4];
    pub const TOTAL_SIZE: usize = 24;

    pub fn checker_lock_arg(mut self, v: PubKeyHash) -> Self {
        self.checker_lock_arg = v;
        self
    }

    pub fn punish_points(mut self, v: Uint32) -> Self {
        self.punish_points = v;
        self
    }
}
impl molecule::prelude::Builder for PunishedCheckerBuilder {
    type Entity = PunishedChecker;

    const NAME: &'static str = "PunishedCheckerBuilder";

    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }

    fn write<W: ::molecule::io::Write>(&self, writer: &mut W) -> ::molecule::io::Result<()> {
        writer.write_all(self.checker_lock_arg.as_slice())?;
        writer.write_all(self.punish_points.as_slice())?;
        Ok(())
    }

    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        PunishedChecker::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct PunishedCheckers(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for PunishedCheckers {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for PunishedCheckers {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for PunishedCheckers {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl ::core::default::Default for PunishedCheckers {
    fn default() -> Self {
        let v: Vec<u8> = vec![0, 0, 0, 0];
        PunishedCheckers::new_unchecked(v.into())
    }
}
impl PunishedCheckers {
    pub const ITEM_SIZE: usize = 24;

    pub fn total_size(&self) -> usize {
        molecule::NUMBER_SIZE * (self.item_count() + 1)
    }

    pub fn item_count(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }

    pub fn len(&self) -> usize {
        self.item_count()
    }

    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }

    pub fn get(&self, idx: usize) -> Option<PunishedChecker> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }

    pub fn get_unchecked(&self, idx: usize) -> PunishedChecker {
        let start = molecule::NUMBER_SIZE + Self::ITEM_SIZE * idx;
        let end = start + Self::ITEM_SIZE;
        PunishedChecker::new_unchecked(self.0.slice(start..end))
    }

    pub fn as_reader<'r>(&'r self) -> PunishedCheckersReader<'r> {
        PunishedCheckersReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for PunishedCheckers {
    type Builder = PunishedCheckersBuilder;

    const NAME: &'static str = "PunishedCheckers";

    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        PunishedCheckers(data)
    }

    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }

    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }

    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        PunishedCheckersReader::from_slice(slice).map(|reader| reader.to_entity())
    }

    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        PunishedCheckersReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }

    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }

    fn as_builder(self) -> Self::Builder {
        Self::new_builder().extend(self.into_iter())
    }
}
#[derive(Clone, Copy)]
pub struct PunishedCheckersReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for PunishedCheckersReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for PunishedCheckersReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for PunishedCheckersReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl<'r> PunishedCheckersReader<'r> {
    pub const ITEM_SIZE: usize = 24;

    pub fn total_size(&self) -> usize {
        molecule::NUMBER_SIZE * (self.item_count() + 1)
    }

    pub fn item_count(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }

    pub fn len(&self) -> usize {
        self.item_count()
    }

    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }

    pub fn get(&self, idx: usize) -> Option<PunishedCheckerReader<'r>> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }

    pub fn get_unchecked(&self, idx: usize) -> PunishedCheckerReader<'r> {
        let start = molecule::NUMBER_SIZE + Self::ITEM_SIZE * idx;
        let end = start + Self::ITEM_SIZE;
        PunishedCheckerReader::new_unchecked(&self.as_slice()[start..end])
    }
}
impl<'r> molecule::prelude::Reader<'r> for PunishedCheckersReader<'r> {
    type Entity = PunishedCheckers;

    const NAME: &'static str = "PunishedCheckersReader";

    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }

    fn new_unchecked(slice: &'r [u8]) -> Self {
        PunishedCheckersReader(slice)
    }

    fn as_slice(&self) -> &'r [u8] {
        self.0
    }

    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let item_count = molecule::unpack_number(slice) as usize;
        if item_count == 0 {
            if slice_len != molecule::NUMBER_SIZE {
                return ve!(Self, TotalSizeNotMatch, molecule::NUMBER_SIZE, slice_len);
            }
            return Ok(());
        }
        let total_size = molecule::NUMBER_SIZE + Self::ITEM_SIZE * item_count;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct PunishedCheckersBuilder(pub(crate) Vec<PunishedChecker>);
impl PunishedCheckersBuilder {
    pub const ITEM_SIZE: usize = 24;

    pub fn set(mut self, v: Vec<PunishedChecker>) -> Self {
        self.0 = v;
        self
    }

    pub fn push(mut self, v: PunishedChecker) -> Self {
        self.0.push(v);
        self
    }

    pub fn extend<T: ::core::iter::IntoIterator<Item = PunishedChecker>>(mut self, iter: T) -> Self {
        for elem in iter {
            self.0.push(elem);
        }
        self
    }
}
impl molecule::prelude::Builder for PunishedCheckersBuilder {
    type Entity = PunishedCheckers;

    const NAME: &'static str = "PunishedCheckersBuilder";

    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.0.len()
    }

    fn write<W: ::molecule::io::Write>(&self, writer: &mut W) -> ::molecule::io::Result<()> {
        writer.write_all(&molecule::pack_number(self.0.len() as molecule::Number))?;
        for inner in &self.0[..] {
            writer.write_all(inner.as_slice())?;
        }
        Ok(())
    }

    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        PunishedCheckers::new_unchecked(inner.into())
    }
}
pub struct PunishedCheckersIterator(PunishedCheckers, usize, usize);
impl ::core::iter::Iterator for PunishedCheckersIterator {
    type Item = PunishedChecker;

    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl ::core::iter::ExactSizeIterator for PunishedCheckersIterator {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::core::iter::IntoIterator for PunishedCheckers {
    type IntoIter = PunishedCheckersIterator;
    type Item = PunishedChecker;

    fn into_iter(self) -> Self::IntoIter {
        let len = self.len();
        PunishedCheckersIterator(self, 0, len)
    }
}
impl<'r> PunishedCheckersReader<'r> {
    pub fn iter<'t>(&'t self) -> PunishedCheckersReaderIterator<'t, 'r> {
        PunishedCheckersReaderIterator(&self, 0, self.len())
    }
}
pub struct PunishedCheckersReaderIterator<'t, 'r>(&'t PunishedCheckersReader<'r>, usize, usize);
impl<'t: 'r, 'r> ::core::iter::Iterator for PunishedCheckersReaderIterator<'t, 'r> {
    type Item = PunishedCheckerReader<'t>;

    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl<'t: 'r, 'r> ::core::iter::ExactSizeIterator for PunishedCheckersReaderIterator<'t, 'r> {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
#[derive(Clone)]
pub struct BlockHeaders(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for BlockHeaders {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for BlockHeaders {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for BlockHeaders {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl ::core::default::Default for BlockHeaders {
    fn default() -> Self {
        let v: Vec<u8> = vec![0, 0, 0, 0];
        BlockHeaders::new_unchecked(v.into())
    }
}
impl BlockHeaders {
    pub const ITEM_SIZE: usize = 32;

    pub fn total_size(&self) -> usize {
        molecule::NUMBER_SIZE * (self.item_count() + 1)
    }

    pub fn item_count(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }

    pub fn len(&self) -> usize {
        self.item_count()
    }

    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }

    pub fn get(&self, idx: usize) -> Option<BlockHeader> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }

    pub fn get_unchecked(&self, idx: usize) -> BlockHeader {
        let start = molecule::NUMBER_SIZE + Self::ITEM_SIZE * idx;
        let end = start + Self::ITEM_SIZE;
        BlockHeader::new_unchecked(self.0.slice(start..end))
    }

    pub fn as_reader<'r>(&'r self) -> BlockHeadersReader<'r> {
        BlockHeadersReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for BlockHeaders {
    type Builder = BlockHeadersBuilder;

    const NAME: &'static str = "BlockHeaders";

    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        BlockHeaders(data)
    }

    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }

    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }

    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BlockHeadersReader::from_slice(slice).map(|reader| reader.to_entity())
    }

    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BlockHeadersReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }

    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }

    fn as_builder(self) -> Self::Builder {
        Self::new_builder().extend(self.into_iter())
    }
}
#[derive(Clone, Copy)]
pub struct BlockHeadersReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for BlockHeadersReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for BlockHeadersReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for BlockHeadersReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl<'r> BlockHeadersReader<'r> {
    pub const ITEM_SIZE: usize = 32;

    pub fn total_size(&self) -> usize {
        molecule::NUMBER_SIZE * (self.item_count() + 1)
    }

    pub fn item_count(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }

    pub fn len(&self) -> usize {
        self.item_count()
    }

    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }

    pub fn get(&self, idx: usize) -> Option<BlockHeaderReader<'r>> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }

    pub fn get_unchecked(&self, idx: usize) -> BlockHeaderReader<'r> {
        let start = molecule::NUMBER_SIZE + Self::ITEM_SIZE * idx;
        let end = start + Self::ITEM_SIZE;
        BlockHeaderReader::new_unchecked(&self.as_slice()[start..end])
    }
}
impl<'r> molecule::prelude::Reader<'r> for BlockHeadersReader<'r> {
    type Entity = BlockHeaders;

    const NAME: &'static str = "BlockHeadersReader";

    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }

    fn new_unchecked(slice: &'r [u8]) -> Self {
        BlockHeadersReader(slice)
    }

    fn as_slice(&self) -> &'r [u8] {
        self.0
    }

    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let item_count = molecule::unpack_number(slice) as usize;
        if item_count == 0 {
            if slice_len != molecule::NUMBER_SIZE {
                return ve!(Self, TotalSizeNotMatch, molecule::NUMBER_SIZE, slice_len);
            }
            return Ok(());
        }
        let total_size = molecule::NUMBER_SIZE + Self::ITEM_SIZE * item_count;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct BlockHeadersBuilder(pub(crate) Vec<BlockHeader>);
impl BlockHeadersBuilder {
    pub const ITEM_SIZE: usize = 32;

    pub fn set(mut self, v: Vec<BlockHeader>) -> Self {
        self.0 = v;
        self
    }

    pub fn push(mut self, v: BlockHeader) -> Self {
        self.0.push(v);
        self
    }

    pub fn extend<T: ::core::iter::IntoIterator<Item = BlockHeader>>(mut self, iter: T) -> Self {
        for elem in iter {
            self.0.push(elem);
        }
        self
    }
}
impl molecule::prelude::Builder for BlockHeadersBuilder {
    type Entity = BlockHeaders;

    const NAME: &'static str = "BlockHeadersBuilder";

    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.0.len()
    }

    fn write<W: ::molecule::io::Write>(&self, writer: &mut W) -> ::molecule::io::Result<()> {
        writer.write_all(&molecule::pack_number(self.0.len() as molecule::Number))?;
        for inner in &self.0[..] {
            writer.write_all(inner.as_slice())?;
        }
        Ok(())
    }

    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        BlockHeaders::new_unchecked(inner.into())
    }
}
pub struct BlockHeadersIterator(BlockHeaders, usize, usize);
impl ::core::iter::Iterator for BlockHeadersIterator {
    type Item = BlockHeader;

    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl ::core::iter::ExactSizeIterator for BlockHeadersIterator {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::core::iter::IntoIterator for BlockHeaders {
    type IntoIter = BlockHeadersIterator;
    type Item = BlockHeader;

    fn into_iter(self) -> Self::IntoIter {
        let len = self.len();
        BlockHeadersIterator(self, 0, len)
    }
}
impl<'r> BlockHeadersReader<'r> {
    pub fn iter<'t>(&'t self) -> BlockHeadersReaderIterator<'t, 'r> {
        BlockHeadersReaderIterator(&self, 0, self.len())
    }
}
pub struct BlockHeadersReaderIterator<'t, 'r>(&'t BlockHeadersReader<'r>, usize, usize);
impl<'t: 'r, 'r> ::core::iter::Iterator for BlockHeadersReaderIterator<'t, 'r> {
    type Item = BlockHeaderReader<'t>;

    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl<'t: 'r, 'r> ::core::iter::ExactSizeIterator for BlockHeadersReaderIterator<'t, 'r> {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
#[derive(Clone)]
pub struct CheckerLastAcceptTaskHeight(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for CheckerLastAcceptTaskHeight {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for CheckerLastAcceptTaskHeight {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for CheckerLastAcceptTaskHeight {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "checker_lock_arg", self.checker_lock_arg())?;
        write!(f, ", {}: {}", "height", self.height())?;
        write!(f, " }}")
    }
}
impl ::core::default::Default for CheckerLastAcceptTaskHeight {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        ];
        CheckerLastAcceptTaskHeight::new_unchecked(v.into())
    }
}
impl CheckerLastAcceptTaskHeight {
    pub const FIELD_COUNT: usize = 2;
    pub const FIELD_SIZES: [usize; 2] = [20, 16];
    pub const TOTAL_SIZE: usize = 36;

    pub fn checker_lock_arg(&self) -> PubKeyHash {
        PubKeyHash::new_unchecked(self.0.slice(0..20))
    }

    pub fn height(&self) -> BlockHeight {
        BlockHeight::new_unchecked(self.0.slice(20..36))
    }

    pub fn as_reader<'r>(&'r self) -> CheckerLastAcceptTaskHeightReader<'r> {
        CheckerLastAcceptTaskHeightReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for CheckerLastAcceptTaskHeight {
    type Builder = CheckerLastAcceptTaskHeightBuilder;

    const NAME: &'static str = "CheckerLastAcceptTaskHeight";

    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        CheckerLastAcceptTaskHeight(data)
    }

    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }

    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }

    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        CheckerLastAcceptTaskHeightReader::from_slice(slice).map(|reader| reader.to_entity())
    }

    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        CheckerLastAcceptTaskHeightReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }

    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }

    fn as_builder(self) -> Self::Builder {
        Self::new_builder().checker_lock_arg(self.checker_lock_arg()).height(self.height())
    }
}
#[derive(Clone, Copy)]
pub struct CheckerLastAcceptTaskHeightReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for CheckerLastAcceptTaskHeightReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for CheckerLastAcceptTaskHeightReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for CheckerLastAcceptTaskHeightReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "checker_lock_arg", self.checker_lock_arg())?;
        write!(f, ", {}: {}", "height", self.height())?;
        write!(f, " }}")
    }
}
impl<'r> CheckerLastAcceptTaskHeightReader<'r> {
    pub const FIELD_COUNT: usize = 2;
    pub const FIELD_SIZES: [usize; 2] = [20, 16];
    pub const TOTAL_SIZE: usize = 36;

    pub fn checker_lock_arg(&self) -> PubKeyHashReader<'r> {
        PubKeyHashReader::new_unchecked(&self.as_slice()[0..20])
    }

    pub fn height(&self) -> BlockHeightReader<'r> {
        BlockHeightReader::new_unchecked(&self.as_slice()[20..36])
    }
}
impl<'r> molecule::prelude::Reader<'r> for CheckerLastAcceptTaskHeightReader<'r> {
    type Entity = CheckerLastAcceptTaskHeight;

    const NAME: &'static str = "CheckerLastAcceptTaskHeightReader";

    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }

    fn new_unchecked(slice: &'r [u8]) -> Self {
        CheckerLastAcceptTaskHeightReader(slice)
    }

    fn as_slice(&self) -> &'r [u8] {
        self.0
    }

    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct CheckerLastAcceptTaskHeightBuilder {
    pub(crate) checker_lock_arg: PubKeyHash,
    pub(crate) height:           BlockHeight,
}
impl CheckerLastAcceptTaskHeightBuilder {
    pub const FIELD_COUNT: usize = 2;
    pub const FIELD_SIZES: [usize; 2] = [20, 16];
    pub const TOTAL_SIZE: usize = 36;

    pub fn checker_lock_arg(mut self, v: PubKeyHash) -> Self {
        self.checker_lock_arg = v;
        self
    }

    pub fn height(mut self, v: BlockHeight) -> Self {
        self.height = v;
        self
    }
}
impl molecule::prelude::Builder for CheckerLastAcceptTaskHeightBuilder {
    type Entity = CheckerLastAcceptTaskHeight;

    const NAME: &'static str = "CheckerLastAcceptTaskHeightBuilder";

    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }

    fn write<W: ::molecule::io::Write>(&self, writer: &mut W) -> ::molecule::io::Result<()> {
        writer.write_all(self.checker_lock_arg.as_slice())?;
        writer.write_all(self.height.as_slice())?;
        Ok(())
    }

    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        CheckerLastAcceptTaskHeight::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct CheckerLastAcceptTaskHeights(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for CheckerLastAcceptTaskHeights {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for CheckerLastAcceptTaskHeights {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for CheckerLastAcceptTaskHeights {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl ::core::default::Default for CheckerLastAcceptTaskHeights {
    fn default() -> Self {
        let v: Vec<u8> = vec![0, 0, 0, 0];
        CheckerLastAcceptTaskHeights::new_unchecked(v.into())
    }
}
impl CheckerLastAcceptTaskHeights {
    pub const ITEM_SIZE: usize = 36;

    pub fn total_size(&self) -> usize {
        molecule::NUMBER_SIZE * (self.item_count() + 1)
    }

    pub fn item_count(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }

    pub fn len(&self) -> usize {
        self.item_count()
    }

    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }

    pub fn get(&self, idx: usize) -> Option<CheckerLastAcceptTaskHeight> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }

    pub fn get_unchecked(&self, idx: usize) -> CheckerLastAcceptTaskHeight {
        let start = molecule::NUMBER_SIZE + Self::ITEM_SIZE * idx;
        let end = start + Self::ITEM_SIZE;
        CheckerLastAcceptTaskHeight::new_unchecked(self.0.slice(start..end))
    }

    pub fn as_reader<'r>(&'r self) -> CheckerLastAcceptTaskHeightsReader<'r> {
        CheckerLastAcceptTaskHeightsReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for CheckerLastAcceptTaskHeights {
    type Builder = CheckerLastAcceptTaskHeightsBuilder;

    const NAME: &'static str = "CheckerLastAcceptTaskHeights";

    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        CheckerLastAcceptTaskHeights(data)
    }

    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }

    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }

    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        CheckerLastAcceptTaskHeightsReader::from_slice(slice).map(|reader| reader.to_entity())
    }

    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        CheckerLastAcceptTaskHeightsReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }

    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }

    fn as_builder(self) -> Self::Builder {
        Self::new_builder().extend(self.into_iter())
    }
}
#[derive(Clone, Copy)]
pub struct CheckerLastAcceptTaskHeightsReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for CheckerLastAcceptTaskHeightsReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for CheckerLastAcceptTaskHeightsReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for CheckerLastAcceptTaskHeightsReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl<'r> CheckerLastAcceptTaskHeightsReader<'r> {
    pub const ITEM_SIZE: usize = 36;

    pub fn total_size(&self) -> usize {
        molecule::NUMBER_SIZE * (self.item_count() + 1)
    }

    pub fn item_count(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }

    pub fn len(&self) -> usize {
        self.item_count()
    }

    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }

    pub fn get(&self, idx: usize) -> Option<CheckerLastAcceptTaskHeightReader<'r>> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }

    pub fn get_unchecked(&self, idx: usize) -> CheckerLastAcceptTaskHeightReader<'r> {
        let start = molecule::NUMBER_SIZE + Self::ITEM_SIZE * idx;
        let end = start + Self::ITEM_SIZE;
        CheckerLastAcceptTaskHeightReader::new_unchecked(&self.as_slice()[start..end])
    }
}
impl<'r> molecule::prelude::Reader<'r> for CheckerLastAcceptTaskHeightsReader<'r> {
    type Entity = CheckerLastAcceptTaskHeights;

    const NAME: &'static str = "CheckerLastAcceptTaskHeightsReader";

    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }

    fn new_unchecked(slice: &'r [u8]) -> Self {
        CheckerLastAcceptTaskHeightsReader(slice)
    }

    fn as_slice(&self) -> &'r [u8] {
        self.0
    }

    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let item_count = molecule::unpack_number(slice) as usize;
        if item_count == 0 {
            if slice_len != molecule::NUMBER_SIZE {
                return ve!(Self, TotalSizeNotMatch, molecule::NUMBER_SIZE, slice_len);
            }
            return Ok(());
        }
        let total_size = molecule::NUMBER_SIZE + Self::ITEM_SIZE * item_count;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct CheckerLastAcceptTaskHeightsBuilder(pub(crate) Vec<CheckerLastAcceptTaskHeight>);
impl CheckerLastAcceptTaskHeightsBuilder {
    pub const ITEM_SIZE: usize = 36;

    pub fn set(mut self, v: Vec<CheckerLastAcceptTaskHeight>) -> Self {
        self.0 = v;
        self
    }

    pub fn push(mut self, v: CheckerLastAcceptTaskHeight) -> Self {
        self.0.push(v);
        self
    }

    pub fn extend<T: ::core::iter::IntoIterator<Item = CheckerLastAcceptTaskHeight>>(mut self, iter: T) -> Self {
        for elem in iter {
            self.0.push(elem);
        }
        self
    }
}
impl molecule::prelude::Builder for CheckerLastAcceptTaskHeightsBuilder {
    type Entity = CheckerLastAcceptTaskHeights;

    const NAME: &'static str = "CheckerLastAcceptTaskHeightsBuilder";

    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.0.len()
    }

    fn write<W: ::molecule::io::Write>(&self, writer: &mut W) -> ::molecule::io::Result<()> {
        writer.write_all(&molecule::pack_number(self.0.len() as molecule::Number))?;
        for inner in &self.0[..] {
            writer.write_all(inner.as_slice())?;
        }
        Ok(())
    }

    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        CheckerLastAcceptTaskHeights::new_unchecked(inner.into())
    }
}
pub struct CheckerLastAcceptTaskHeightsIterator(CheckerLastAcceptTaskHeights, usize, usize);
impl ::core::iter::Iterator for CheckerLastAcceptTaskHeightsIterator {
    type Item = CheckerLastAcceptTaskHeight;

    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl ::core::iter::ExactSizeIterator for CheckerLastAcceptTaskHeightsIterator {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::core::iter::IntoIterator for CheckerLastAcceptTaskHeights {
    type IntoIter = CheckerLastAcceptTaskHeightsIterator;
    type Item = CheckerLastAcceptTaskHeight;

    fn into_iter(self) -> Self::IntoIter {
        let len = self.len();
        CheckerLastAcceptTaskHeightsIterator(self, 0, len)
    }
}
impl<'r> CheckerLastAcceptTaskHeightsReader<'r> {
    pub fn iter<'t>(&'t self) -> CheckerLastAcceptTaskHeightsReaderIterator<'t, 'r> {
        CheckerLastAcceptTaskHeightsReaderIterator(&self, 0, self.len())
    }
}
pub struct CheckerLastAcceptTaskHeightsReaderIterator<'t, 'r>(&'t CheckerLastAcceptTaskHeightsReader<'r>, usize, usize);
impl<'t: 'r, 'r> ::core::iter::Iterator for CheckerLastAcceptTaskHeightsReaderIterator<'t, 'r> {
    type Item = CheckerLastAcceptTaskHeightReader<'t>;

    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl<'t: 'r, 'r> ::core::iter::ExactSizeIterator for CheckerLastAcceptTaskHeightsReaderIterator<'t, 'r> {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
#[derive(Clone)]
pub struct SidechainStateCell(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for SidechainStateCell {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for SidechainStateCell {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for SidechainStateCell {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "version", self.version())?;
        write!(f, ", {}: {}", "submit_sidechain_block_height", self.submit_sidechain_block_height())?;
        write!(f, ", {}: {}", "waiting_jobs", self.waiting_jobs())?;
        write!(f, ", {}: {}", "random_seed", self.random_seed())?;
        write!(f, ", {}: {}", "random_offset", self.random_offset())?;
        write!(f, ", {}: {}", "random_commit", self.random_commit())?;
        write!(f, ", {}: {}", "punish_checkers", self.punish_checkers())?;
        write!(f, ", {}: {}", "recent_block_headers", self.recent_block_headers())?;
        write!(
            f,
            ", {}: {}",
            "ancient_block_heard_merkle_root",
            self.ancient_block_heard_merkle_root()
        )?;
        write!(
            f,
            ", {}: {}",
            "checker_last_task_sidechain_heights",
            self.checker_last_task_sidechain_heights()
        )?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for SidechainStateCell {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            146, 0, 0, 0, 44, 0, 0, 0, 45, 0, 0, 0, 61, 0, 0, 0, 65, 0, 0, 0, 97, 0, 0, 0, 98, 0, 0, 0, 102, 0, 0, 0, 106, 0, 0, 0, 110, 0,
            0, 0, 142, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        ];
        SidechainStateCell::new_unchecked(v.into())
    }
}
impl SidechainStateCell {
    pub const FIELD_COUNT: usize = 10;

    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }

    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }

    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }

    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }

    pub fn version(&self) -> Uint8 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Uint8::new_unchecked(self.0.slice(start..end))
    }

    pub fn submit_sidechain_block_height(&self) -> BlockHeight {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        BlockHeight::new_unchecked(self.0.slice(start..end))
    }

    pub fn waiting_jobs(&self) -> Jobs {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        Jobs::new_unchecked(self.0.slice(start..end))
    }

    pub fn random_seed(&self) -> RandomSeed {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        RandomSeed::new_unchecked(self.0.slice(start..end))
    }

    pub fn random_offset(&self) -> Uint8 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        let end = molecule::unpack_number(&slice[24..]) as usize;
        Uint8::new_unchecked(self.0.slice(start..end))
    }

    pub fn random_commit(&self) -> CommittedCheckerInfos {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[24..]) as usize;
        let end = molecule::unpack_number(&slice[28..]) as usize;
        CommittedCheckerInfos::new_unchecked(self.0.slice(start..end))
    }

    pub fn punish_checkers(&self) -> PunishedCheckers {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[28..]) as usize;
        let end = molecule::unpack_number(&slice[32..]) as usize;
        PunishedCheckers::new_unchecked(self.0.slice(start..end))
    }

    pub fn recent_block_headers(&self) -> BlockHeaders {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[32..]) as usize;
        let end = molecule::unpack_number(&slice[36..]) as usize;
        BlockHeaders::new_unchecked(self.0.slice(start..end))
    }

    pub fn ancient_block_heard_merkle_root(&self) -> MerkleHash {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[36..]) as usize;
        let end = molecule::unpack_number(&slice[40..]) as usize;
        MerkleHash::new_unchecked(self.0.slice(start..end))
    }

    pub fn checker_last_task_sidechain_heights(&self) -> CheckerLastAcceptTaskHeights {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[40..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[44..]) as usize;
            CheckerLastAcceptTaskHeights::new_unchecked(self.0.slice(start..end))
        } else {
            CheckerLastAcceptTaskHeights::new_unchecked(self.0.slice(start..))
        }
    }

    pub fn as_reader<'r>(&'r self) -> SidechainStateCellReader<'r> {
        SidechainStateCellReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for SidechainStateCell {
    type Builder = SidechainStateCellBuilder;

    const NAME: &'static str = "SidechainStateCell";

    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        SidechainStateCell(data)
    }

    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }

    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }

    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        SidechainStateCellReader::from_slice(slice).map(|reader| reader.to_entity())
    }

    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        SidechainStateCellReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }

    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }

    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .version(self.version())
            .submit_sidechain_block_height(self.submit_sidechain_block_height())
            .waiting_jobs(self.waiting_jobs())
            .random_seed(self.random_seed())
            .random_offset(self.random_offset())
            .random_commit(self.random_commit())
            .punish_checkers(self.punish_checkers())
            .recent_block_headers(self.recent_block_headers())
            .ancient_block_heard_merkle_root(self.ancient_block_heard_merkle_root())
            .checker_last_task_sidechain_heights(self.checker_last_task_sidechain_heights())
    }
}
#[derive(Clone, Copy)]
pub struct SidechainStateCellReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for SidechainStateCellReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for SidechainStateCellReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for SidechainStateCellReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "version", self.version())?;
        write!(f, ", {}: {}", "submit_sidechain_block_height", self.submit_sidechain_block_height())?;
        write!(f, ", {}: {}", "waiting_jobs", self.waiting_jobs())?;
        write!(f, ", {}: {}", "random_seed", self.random_seed())?;
        write!(f, ", {}: {}", "random_offset", self.random_offset())?;
        write!(f, ", {}: {}", "random_commit", self.random_commit())?;
        write!(f, ", {}: {}", "punish_checkers", self.punish_checkers())?;
        write!(f, ", {}: {}", "recent_block_headers", self.recent_block_headers())?;
        write!(
            f,
            ", {}: {}",
            "ancient_block_heard_merkle_root",
            self.ancient_block_heard_merkle_root()
        )?;
        write!(
            f,
            ", {}: {}",
            "checker_last_task_sidechain_heights",
            self.checker_last_task_sidechain_heights()
        )?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> SidechainStateCellReader<'r> {
    pub const FIELD_COUNT: usize = 10;

    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }

    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }

    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }

    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }

    pub fn version(&self) -> Uint8Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Uint8Reader::new_unchecked(&self.as_slice()[start..end])
    }

    pub fn submit_sidechain_block_height(&self) -> BlockHeightReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        BlockHeightReader::new_unchecked(&self.as_slice()[start..end])
    }

    pub fn waiting_jobs(&self) -> JobsReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        JobsReader::new_unchecked(&self.as_slice()[start..end])
    }

    pub fn random_seed(&self) -> RandomSeedReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        RandomSeedReader::new_unchecked(&self.as_slice()[start..end])
    }

    pub fn random_offset(&self) -> Uint8Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        let end = molecule::unpack_number(&slice[24..]) as usize;
        Uint8Reader::new_unchecked(&self.as_slice()[start..end])
    }

    pub fn random_commit(&self) -> CommittedCheckerInfosReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[24..]) as usize;
        let end = molecule::unpack_number(&slice[28..]) as usize;
        CommittedCheckerInfosReader::new_unchecked(&self.as_slice()[start..end])
    }

    pub fn punish_checkers(&self) -> PunishedCheckersReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[28..]) as usize;
        let end = molecule::unpack_number(&slice[32..]) as usize;
        PunishedCheckersReader::new_unchecked(&self.as_slice()[start..end])
    }

    pub fn recent_block_headers(&self) -> BlockHeadersReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[32..]) as usize;
        let end = molecule::unpack_number(&slice[36..]) as usize;
        BlockHeadersReader::new_unchecked(&self.as_slice()[start..end])
    }

    pub fn ancient_block_heard_merkle_root(&self) -> MerkleHashReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[36..]) as usize;
        let end = molecule::unpack_number(&slice[40..]) as usize;
        MerkleHashReader::new_unchecked(&self.as_slice()[start..end])
    }

    pub fn checker_last_task_sidechain_heights(&self) -> CheckerLastAcceptTaskHeightsReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[40..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[44..]) as usize;
            CheckerLastAcceptTaskHeightsReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            CheckerLastAcceptTaskHeightsReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for SidechainStateCellReader<'r> {
    type Entity = SidechainStateCell;

    const NAME: &'static str = "SidechainStateCellReader";

    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }

    fn new_unchecked(slice: &'r [u8]) -> Self {
        SidechainStateCellReader(slice)
    }

    fn as_slice(&self) -> &'r [u8] {
        self.0
    }

    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE && Self::FIELD_COUNT == 0 {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Uint8Reader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        BlockHeightReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        JobsReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        RandomSeedReader::verify(&slice[offsets[3]..offsets[4]], compatible)?;
        Uint8Reader::verify(&slice[offsets[4]..offsets[5]], compatible)?;
        CommittedCheckerInfosReader::verify(&slice[offsets[5]..offsets[6]], compatible)?;
        PunishedCheckersReader::verify(&slice[offsets[6]..offsets[7]], compatible)?;
        BlockHeadersReader::verify(&slice[offsets[7]..offsets[8]], compatible)?;
        MerkleHashReader::verify(&slice[offsets[8]..offsets[9]], compatible)?;
        CheckerLastAcceptTaskHeightsReader::verify(&slice[offsets[9]..offsets[10]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct SidechainStateCellBuilder {
    pub(crate) version: Uint8,
    pub(crate) submit_sidechain_block_height: BlockHeight,
    pub(crate) waiting_jobs: Jobs,
    pub(crate) random_seed: RandomSeed,
    pub(crate) random_offset: Uint8,
    pub(crate) random_commit: CommittedCheckerInfos,
    pub(crate) punish_checkers: PunishedCheckers,
    pub(crate) recent_block_headers: BlockHeaders,
    pub(crate) ancient_block_heard_merkle_root: MerkleHash,
    pub(crate) checker_last_task_sidechain_heights: CheckerLastAcceptTaskHeights,
}
impl SidechainStateCellBuilder {
    pub const FIELD_COUNT: usize = 10;

    pub fn version(mut self, v: Uint8) -> Self {
        self.version = v;
        self
    }

    pub fn submit_sidechain_block_height(mut self, v: BlockHeight) -> Self {
        self.submit_sidechain_block_height = v;
        self
    }

    pub fn waiting_jobs(mut self, v: Jobs) -> Self {
        self.waiting_jobs = v;
        self
    }

    pub fn random_seed(mut self, v: RandomSeed) -> Self {
        self.random_seed = v;
        self
    }

    pub fn random_offset(mut self, v: Uint8) -> Self {
        self.random_offset = v;
        self
    }

    pub fn random_commit(mut self, v: CommittedCheckerInfos) -> Self {
        self.random_commit = v;
        self
    }

    pub fn punish_checkers(mut self, v: PunishedCheckers) -> Self {
        self.punish_checkers = v;
        self
    }

    pub fn recent_block_headers(mut self, v: BlockHeaders) -> Self {
        self.recent_block_headers = v;
        self
    }

    pub fn ancient_block_heard_merkle_root(mut self, v: MerkleHash) -> Self {
        self.ancient_block_heard_merkle_root = v;
        self
    }

    pub fn checker_last_task_sidechain_heights(mut self, v: CheckerLastAcceptTaskHeights) -> Self {
        self.checker_last_task_sidechain_heights = v;
        self
    }
}
impl molecule::prelude::Builder for SidechainStateCellBuilder {
    type Entity = SidechainStateCell;

    const NAME: &'static str = "SidechainStateCellBuilder";

    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.version.as_slice().len()
            + self.submit_sidechain_block_height.as_slice().len()
            + self.waiting_jobs.as_slice().len()
            + self.random_seed.as_slice().len()
            + self.random_offset.as_slice().len()
            + self.random_commit.as_slice().len()
            + self.punish_checkers.as_slice().len()
            + self.recent_block_headers.as_slice().len()
            + self.ancient_block_heard_merkle_root.as_slice().len()
            + self.checker_last_task_sidechain_heights.as_slice().len()
    }

    fn write<W: ::molecule::io::Write>(&self, writer: &mut W) -> ::molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.version.as_slice().len();
        offsets.push(total_size);
        total_size += self.submit_sidechain_block_height.as_slice().len();
        offsets.push(total_size);
        total_size += self.waiting_jobs.as_slice().len();
        offsets.push(total_size);
        total_size += self.random_seed.as_slice().len();
        offsets.push(total_size);
        total_size += self.random_offset.as_slice().len();
        offsets.push(total_size);
        total_size += self.random_commit.as_slice().len();
        offsets.push(total_size);
        total_size += self.punish_checkers.as_slice().len();
        offsets.push(total_size);
        total_size += self.recent_block_headers.as_slice().len();
        offsets.push(total_size);
        total_size += self.ancient_block_heard_merkle_root.as_slice().len();
        offsets.push(total_size);
        total_size += self.checker_last_task_sidechain_heights.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.version.as_slice())?;
        writer.write_all(self.submit_sidechain_block_height.as_slice())?;
        writer.write_all(self.waiting_jobs.as_slice())?;
        writer.write_all(self.random_seed.as_slice())?;
        writer.write_all(self.random_offset.as_slice())?;
        writer.write_all(self.random_commit.as_slice())?;
        writer.write_all(self.punish_checkers.as_slice())?;
        writer.write_all(self.recent_block_headers.as_slice())?;
        writer.write_all(self.ancient_block_heard_merkle_root.as_slice())?;
        writer.write_all(self.checker_last_task_sidechain_heights.as_slice())?;
        Ok(())
    }

    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        SidechainStateCell::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct SidechainStateCellTypeArgs(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for SidechainStateCellTypeArgs {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for SidechainStateCellTypeArgs {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for SidechainStateCellTypeArgs {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "chain_id", self.chain_id())?;
        write!(f, " }}")
    }
}
impl ::core::default::Default for SidechainStateCellTypeArgs {
    fn default() -> Self {
        let v: Vec<u8> = vec![0, 0, 0, 0];
        SidechainStateCellTypeArgs::new_unchecked(v.into())
    }
}
impl SidechainStateCellTypeArgs {
    pub const FIELD_COUNT: usize = 1;
    pub const FIELD_SIZES: [usize; 1] = [4];
    pub const TOTAL_SIZE: usize = 4;

    pub fn chain_id(&self) -> ChainId {
        ChainId::new_unchecked(self.0.slice(0..4))
    }

    pub fn as_reader<'r>(&'r self) -> SidechainStateCellTypeArgsReader<'r> {
        SidechainStateCellTypeArgsReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for SidechainStateCellTypeArgs {
    type Builder = SidechainStateCellTypeArgsBuilder;

    const NAME: &'static str = "SidechainStateCellTypeArgs";

    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        SidechainStateCellTypeArgs(data)
    }

    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }

    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }

    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        SidechainStateCellTypeArgsReader::from_slice(slice).map(|reader| reader.to_entity())
    }

    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        SidechainStateCellTypeArgsReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }

    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }

    fn as_builder(self) -> Self::Builder {
        Self::new_builder().chain_id(self.chain_id())
    }
}
#[derive(Clone, Copy)]
pub struct SidechainStateCellTypeArgsReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for SidechainStateCellTypeArgsReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for SidechainStateCellTypeArgsReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for SidechainStateCellTypeArgsReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "chain_id", self.chain_id())?;
        write!(f, " }}")
    }
}
impl<'r> SidechainStateCellTypeArgsReader<'r> {
    pub const FIELD_COUNT: usize = 1;
    pub const FIELD_SIZES: [usize; 1] = [4];
    pub const TOTAL_SIZE: usize = 4;

    pub fn chain_id(&self) -> ChainIdReader<'r> {
        ChainIdReader::new_unchecked(&self.as_slice()[0..4])
    }
}
impl<'r> molecule::prelude::Reader<'r> for SidechainStateCellTypeArgsReader<'r> {
    type Entity = SidechainStateCellTypeArgs;

    const NAME: &'static str = "SidechainStateCellTypeArgsReader";

    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }

    fn new_unchecked(slice: &'r [u8]) -> Self {
        SidechainStateCellTypeArgsReader(slice)
    }

    fn as_slice(&self) -> &'r [u8] {
        self.0
    }

    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct SidechainStateCellTypeArgsBuilder {
    pub(crate) chain_id: ChainId,
}
impl SidechainStateCellTypeArgsBuilder {
    pub const FIELD_COUNT: usize = 1;
    pub const FIELD_SIZES: [usize; 1] = [4];
    pub const TOTAL_SIZE: usize = 4;

    pub fn chain_id(mut self, v: ChainId) -> Self {
        self.chain_id = v;
        self
    }
}
impl molecule::prelude::Builder for SidechainStateCellTypeArgsBuilder {
    type Entity = SidechainStateCellTypeArgs;

    const NAME: &'static str = "SidechainStateCellTypeArgsBuilder";

    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }

    fn write<W: ::molecule::io::Write>(&self, writer: &mut W) -> ::molecule::io::Result<()> {
        writer.write_all(self.chain_id.as_slice())?;
        Ok(())
    }

    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        SidechainStateCellTypeArgs::new_unchecked(inner.into())
    }
}
